---
# Ceiling LED Ring - Air Quality & Night Mode Feature Package
#
# Provides an 8-LED WS2812B addressable ring for sense360 ceiling devices
# with air quality status visualization and night mode support.
#
# Features:
# - 8 WS2812B LEDs in ring configuration
# - Air quality color mapping (Green/Orange/Red/Purple)
# - Night mode with automatic brightness reduction
# - Pulsing effect for poor air quality alerts
# - Configurable thresholds and timing
#
# Required sensors (from airiq.yaml expansion package):
# - airiq_pm2_5: PM2.5 sensor (µg/m³)
# - airiq_voc_index: VOC index sensor (optional)
# - airiq_co2: CO2 sensor (optional)
#
# Color Mapping:
# - Good:      Green (0, 255, 0)
# - Moderate:  Orange (255, 128, 0)
# - Unhealthy: Red (255, 0, 0)
# - Poor:      Purple (128, 0, 255) with pulsing
# - Unknown:   Dim blue/gray (24, 32, 64)
#
# Usage:
#   packages:
#     ceiling_hardware: !include ../hardware/sense360_core_ceiling.yaml
#     airiq_sensors: !include ../expansions/airiq.yaml
#     led_ring: !include ceiling_led_ring_air_quality.yaml

substitutions:
  # LED Ring Hardware Configuration
  led_ring_pin: GPIO5
  led_ring_num_leds: "8"
  led_ring_transition: 250ms

  # Sensor IDs (must match your air quality expansion package)
  # Default values match airiq.yaml sensor IDs
  pm25_sensor_id: airiq_pm2_5
  voc_sensor_id: airiq_voc_index
  co2_sensor_id: airiq_co2

  # Night Mode Time Configuration (24-hour format)
  night_mode_start_hour: "22"
  night_mode_start_minute: "0"
  night_mode_end_hour: "7"
  night_mode_end_minute: "0"

  # Brightness Settings
  day_brightness: "100"      # Percentage (1-100)
  night_brightness: "15"     # Percentage (1-100)

  # Air Quality Thresholds (PM2.5 in µg/m³)
  pm25_good_threshold: "10.0"
  pm25_moderate_threshold: "25.0"
  pm25_unhealthy_threshold: "50.0"

  # VOC Index Thresholds (0-500 scale)
  voc_good_threshold: "80.0"
  voc_moderate_threshold: "150.0"
  voc_unhealthy_threshold: "250.0"

  # CO2 Thresholds (ppm)
  co2_good_threshold: "750.0"
  co2_moderate_threshold: "1000.0"
  co2_unhealthy_threshold: "1500.0"

esphome:
  includes:
    - ../../include/sense360/led_logic.h
    - ../../include/sense360/thresholds.h
    - ../../include/sense360/time_utils.h

# Global variables for night mode and LED state
globals:
  - id: night_mode_enabled
    type: bool
    restore_value: true
    initial_value: "true"

  - id: night_mode_override
    type: int
    restore_value: true
    initial_value: "0"  # 0=AUTO, 1=FORCE_OFF, 2=FORCE_ON

  - id: led_ring_enabled
    type: bool
    restore_value: true
    initial_value: "true"

  - id: current_brightness_pct
    type: int
    restore_value: false
    initial_value: "${day_brightness}"

  - id: air_quality_mode_active
    type: bool
    restore_value: true
    initial_value: "true"

# LED Ring Light Configuration
light:
  - platform: esp32_rmt_led_strip
    id: led_ring
    name: "${friendly_name} LED Ring"
    pin: ${led_ring_pin}
    num_leds: ${led_ring_num_leds}
    chipset: ws2812
    rgb_order: GRB
    rmt_channel: 0
    default_transition_length: ${led_ring_transition}
    restore_mode: RESTORE_DEFAULT_ON
    effects:
      # Static color effect (manual control)
      - addressable_color_wipe:
          name: "Color Wipe"
          add_led_interval: 100ms

      - addressable_rainbow:
          name: "Rainbow"
          speed: 10
          width: 50

      # Air Quality Status Effect
      - addressable_lambda:
          name: "Air Quality Status"
          update_interval: 1s
          lambda: |-
            using namespace sense360::led;
            using namespace sense360::time_utils;

            // Check if LED ring is enabled
            if (!id(led_ring_enabled)) {
              it.all() = Color(0, 0, 0);
              return;
            }

            // Get air quality sensor values (with NaN handling)
            float pm25 = NAN;
            float voc = NAN;
            float co2 = NAN;

            // Try to get PM2.5 value if sensor exists
            if (id(${pm25_sensor_id}).has_state()) {
              pm25 = id(${pm25_sensor_id}).state;
            }
            // Try to get VOC value if sensor exists
            if (id(${voc_sensor_id}).has_state()) {
              voc = id(${voc_sensor_id}).state;
            }
            // Try to get CO2 value if sensor exists
            if (id(${co2_sensor_id}).has_state()) {
              co2 = id(${co2_sensor_id}).state;
            }

            // Compute severity levels for each sensor
            int pm_level = compute_level(pm25,
                                        ${pm25_good_threshold},
                                        ${pm25_moderate_threshold},
                                        ${pm25_unhealthy_threshold});

            int voc_level = compute_level(voc,
                                         ${voc_good_threshold},
                                         ${voc_moderate_threshold},
                                         ${voc_unhealthy_threshold});

            int co2_level = compute_level(co2,
                                         ${co2_good_threshold},
                                         ${co2_moderate_threshold},
                                         ${co2_unhealthy_threshold});

            // Get overall worst severity
            int overall_level = compute_overall_severity(pm_level, voc_level, LEVEL_UNKNOWN, co2_level);

            // Get base color for severity level
            sense360::led::Color base_color = color_for_severity(overall_level);

            // Calculate brightness based on severity
            float base_brightness = brightness_scale_for_level(overall_level);

            // Apply night mode dimming
            float night_dim = static_cast<float>(id(current_brightness_pct)) / 100.0f;
            float final_brightness = base_brightness * night_dim;

            // Apply pulsing for poor air quality
            if (overall_level == LEVEL_POOR) {
              final_brightness *= compute_pulse_multiplier(millis());
            }

            // Scale color by final brightness
            sense360::led::Color final_color = scale_color(base_color, final_brightness);

            // Apply to all LEDs in the ring
            for (int i = 0; i < it.size(); i++) {
              it[i] = ESPColor(final_color.red, final_color.green, final_color.blue);
            }

      # Night Mode Indicator Effect (dim white)
      - addressable_lambda:
          name: "Night Light"
          update_interval: 500ms
          lambda: |-
            if (!id(led_ring_enabled)) {
              it.all() = Color(0, 0, 0);
              return;
            }

            float brightness = static_cast<float>(id(current_brightness_pct)) / 100.0f;
            uint8_t val = static_cast<uint8_t>(255.0f * brightness * 0.3f);

            for (int i = 0; i < it.size(); i++) {
              it[i] = ESPColor(val, val, val);
            }

      # Presence Alert Effect (breathing)
      - addressable_lambda:
          name: "Presence Breathing"
          update_interval: 50ms
          lambda: |-
            if (!id(led_ring_enabled)) {
              it.all() = Color(0, 0, 0);
              return;
            }

            float phase = static_cast<float>(millis() % 3000) / 3000.0f;
            float breath = 0.3f + 0.7f * (0.5f + 0.5f * sin(phase * 2.0f * 3.14159265f));
            float night_dim = static_cast<float>(id(current_brightness_pct)) / 100.0f;

            uint8_t val = static_cast<uint8_t>(255.0f * breath * night_dim);

            for (int i = 0; i < it.size(); i++) {
              it[i] = ESPColor(0, val, val);  // Cyan breathing
            }

      # Startup Animation
      - addressable_lambda:
          name: "Startup Sequence"
          update_interval: 50ms
          lambda: |-
            static int startup_frame = 0;
            const int total_frames = 160;  // 8 seconds total

            if (startup_frame < total_frames) {
              int led_index = (startup_frame / 20) % it.size();
              float fade = static_cast<float>(startup_frame % 20) / 20.0f;

              it.all() = ESPColor(0, 0, 0);
              it[led_index] = ESPColor(0, static_cast<uint8_t>(255 * fade), 0);

              startup_frame++;
            } else {
              // Animation complete, switch to air quality mode
              startup_frame = 0;
              auto call = id(led_ring).turn_on();
              call.set_effect("Air Quality Status");
              call.perform();
            }

# Script to update night mode brightness
script:
  - id: update_night_mode_brightness
    then:
      - lambda: |-
          using namespace sense360::time_utils;

          // Get current time
          auto now = id(sntp_time).now();
          if (!now.is_valid()) {
            // Time not available, use day brightness
            id(current_brightness_pct) = ${day_brightness};
            return;
          }

          Time current(now.hour, now.minute);
          Time night_start(${night_mode_start_hour}, ${night_mode_start_minute});
          Time night_end(${night_mode_end_hour}, ${night_mode_end_minute});

          // Check if we should be in night mode
          bool is_night = should_be_night_mode(
            current,
            night_start,
            night_end,
            id(night_mode_enabled),
            static_cast<NightModeOverride>(id(night_mode_override)),
            true  // time is valid
          );

          // Set brightness accordingly using user-adjustable values
          if (is_night) {
            int night_val = static_cast<int>(id(night_brightness_setting).state);
            id(current_brightness_pct) = night_val;
            ESP_LOGD("led_ring", "Night mode active - brightness: %d%%", night_val);
          } else {
            int day_val = static_cast<int>(id(day_brightness_setting).state);
            id(current_brightness_pct) = day_val;
            ESP_LOGD("led_ring", "Day mode active - brightness: %d%%", day_val);
          }

# Interval to periodically check night mode
interval:
  - interval: 60s
    then:
      - script.execute: update_night_mode_brightness

# Time source (required for night mode)
time:
  - platform: sntp
    id: sntp_time
    timezone: ${timezone}
    on_time_sync:
      then:
        - script.execute: update_night_mode_brightness
        - logger.log: "Time synchronized - updating night mode status"

# Switches for controlling LED ring features
switch:
  - platform: template
    id: led_ring_power_switch
    name: "${friendly_name} LED Ring"
    icon: mdi:led-on
    restore_mode: RESTORE_DEFAULT_ON
    lambda: return id(led_ring_enabled);
    turn_on_action:
      - globals.set:
          id: led_ring_enabled
          value: "true"
      - light.turn_on:
          id: led_ring
          effect: "Air Quality Status"
    turn_off_action:
      - globals.set:
          id: led_ring_enabled
          value: "false"
      - light.turn_off: led_ring

  - platform: template
    id: night_mode_switch
    name: "${friendly_name} Night Mode"
    icon: mdi:weather-night
    restore_mode: RESTORE_DEFAULT_ON
    lambda: return id(night_mode_enabled);
    turn_on_action:
      - globals.set:
          id: night_mode_enabled
          value: "true"
      - script.execute: update_night_mode_brightness
    turn_off_action:
      - globals.set:
          id: night_mode_enabled
          value: "false"
      - script.execute: update_night_mode_brightness

  - platform: template
    id: air_quality_mode_switch
    name: "${friendly_name} Air Quality Display"
    icon: mdi:air-filter
    restore_mode: RESTORE_DEFAULT_ON
    lambda: return id(air_quality_mode_active);
    turn_on_action:
      - globals.set:
          id: air_quality_mode_active
          value: "true"
      - light.turn_on:
          id: led_ring
          effect: "Air Quality Status"
    turn_off_action:
      - globals.set:
          id: air_quality_mode_active
          value: "false"
      - light.turn_on:
          id: led_ring
          effect: "none"

# Select for night mode override
select:
  - platform: template
    id: night_mode_override_select
    name: "${friendly_name} Night Mode Override"
    icon: mdi:cog
    optimistic: true
    restore_value: true
    options:
      - "Auto"
      - "Force Day"
      - "Force Night"
    initial_option: "Auto"
    on_value:
      then:
        - lambda: |-
            if (x == "Auto") {
              id(night_mode_override) = 0;
            } else if (x == "Force Day") {
              id(night_mode_override) = 1;
            } else if (x == "Force Night") {
              id(night_mode_override) = 2;
            }
        - script.execute: update_night_mode_brightness

# Number inputs for adjustable brightness levels
number:
  - platform: template
    id: day_brightness_setting
    name: "${friendly_name} Day Brightness"
    icon: mdi:brightness-7
    unit_of_measurement: "%"
    min_value: 10
    max_value: 100
    step: 5
    initial_value: ${day_brightness}
    optimistic: true
    restore_value: true
    set_action:
      - script.execute: update_night_mode_brightness

  - platform: template
    id: night_brightness_setting
    name: "${friendly_name} Night Brightness"
    icon: mdi:brightness-3
    unit_of_measurement: "%"
    min_value: 1
    max_value: 50
    step: 1
    initial_value: ${night_brightness}
    optimistic: true
    restore_value: true
    set_action:
      - script.execute: update_night_mode_brightness

# Text sensor for current air quality status
text_sensor:
  - platform: template
    id: air_quality_status_text
    name: "${friendly_name} Air Quality Status"
    icon: mdi:leaf
    update_interval: 5s
    lambda: |-
      using namespace sense360::led;

      float pm25 = NAN;
      float voc = NAN;
      float co2 = NAN;

      if (id(${pm25_sensor_id}).has_state()) pm25 = id(${pm25_sensor_id}).state;
      if (id(${voc_sensor_id}).has_state()) voc = id(${voc_sensor_id}).state;
      if (id(${co2_sensor_id}).has_state()) co2 = id(${co2_sensor_id}).state;

      int pm_level = compute_level(
          pm25,
          ${pm25_good_threshold},
          ${pm25_moderate_threshold},
          ${pm25_unhealthy_threshold});
      int voc_level = compute_level(
          voc,
          ${voc_good_threshold},
          ${voc_moderate_threshold},
          ${voc_unhealthy_threshold});
      int co2_level = compute_level(
          co2,
          ${co2_good_threshold},
          ${co2_moderate_threshold},
          ${co2_unhealthy_threshold});
      int overall = compute_overall_severity(pm_level, voc_level, LEVEL_UNKNOWN, co2_level);

      switch (overall) {
        case LEVEL_GOOD:      return std::string("Good");
        case LEVEL_MODERATE:  return std::string("Moderate");
        case LEVEL_UNHEALTHY: return std::string("Unhealthy");
        case LEVEL_POOR:      return std::string("Poor");
        default:              return std::string("Unknown");
      }

# Sensor for current brightness
sensor:
  - platform: template
    id: current_brightness_sensor
    name: "${friendly_name} LED Brightness"
    icon: mdi:brightness-percent
    unit_of_measurement: "%"
    accuracy_decimals: 0
    update_interval: 10s
    lambda: return static_cast<float>(id(current_brightness_pct));
