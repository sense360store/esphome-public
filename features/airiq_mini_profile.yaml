# /config/esphome/packages/features/airiq_mini_profile.yaml
# Mini AirIQ: SEN55 + SCD4x + SHT30 + LTR303.
# Requires: i2c bus id i2c0 (from core hardware) and script id mini_update_4leds (from LED package).

# --- Globals (must exist before esphome:on_boot uses them) ---
globals:
  # One-time SCD4x forced-calibration flag (persisted across reboots)
  - id: scd4x_cal_done
    type: bool
    restore_value: true
    initial_value: 'false'

  # CO₂ thresholds
  - id: g_co2_good
    type: float
    restore_value: true
    initial_value: ${co2_good_limit}
  - id: g_co2_moderate
    type: float
    restore_value: true
    initial_value: ${co2_moderate_limit}
  - id: g_co2_unhealthy
    type: float
    restore_value: true
    initial_value: ${co2_unhealthy_limit}

  # PM2.5 thresholds (for the PM LED)
  - id: g_pm25_good
    type: float
    restore_value: true
    initial_value: ${sen55_pm2_5_good_limit}
  - id: g_pm25_moderate
    type: float
    restore_value: true
    initial_value: ${sen55_pm2_5_moderate_limit}
  - id: g_pm25_unhealthy
    type: float
    restore_value: true
    initial_value: ${sen55_pm2_5_unhealthy_limit}

  # VOC thresholds
  - id: g_voc_good
    type: float
    restore_value: true
    initial_value: ${sen55_voc_good_limit}
  - id: g_voc_moderate
    type: float
    restore_value: true
    initial_value: ${sen55_voc_moderate_limit}
  - id: g_voc_unhealthy
    type: float
    restore_value: true
    initial_value: ${sen55_voc_unhealthy_limit}

  # NOx thresholds
  - id: g_nox_good
    type: float
    restore_value: true
    initial_value: ${sen55_nox_good_limit}
  - id: g_nox_moderate
    type: float
    restore_value: true
    initial_value: ${sen55_nox_moderate_limit}
  - id: g_nox_unhealthy
    type: float
    restore_value: true
    initial_value: ${sen55_nox_unhealthy_limit}

  # --- Committed (persistent) SHT30 calibration baselines ---
  - id: sht30_dt_committed       # °C
    type: float
    restore_value: true
    initial_value: '0.0'
  - id: sht30_rh_b_committed     # %RH
    type: float
    restore_value: true
    initial_value: '0.0'
  - id: sht30_cal_pending        # triggers calibration once raw readings are ready
    type: bool
    restore_value: true
    initial_value: 'false'

# --- SHT30 calibration UI (minimal) ---
number:
  # Visible reference inputs (user types these in HA)
  - platform: template
    id: sht30_ref_t
    name: "${friendly_name} Cal Reference Temp (°C)"
    unit_of_measurement: "°C"
    min_value: -20
    max_value: 80
    step: 0.01
    mode: box
    restore_value: true
    initial_value: 17.5
    optimistic: true
    on_value:
      # Debounced auto-apply so HA text entry does not spam flash writes
      - lambda: 'id(sht30_cal_pending) = true;'
      - script.execute: sht30_debounced_apply_single_point_cal

  - platform: template
    id: sht30_ref_rh
    name: "${friendly_name} Cal Reference RH (%)"
    unit_of_measurement: "%"
    min_value: 0
    max_value: 100
    step: 0.1
    mode: box
    restore_value: true
    initial_value: 73.0
    optimistic: true
    on_value:
      # Debounced auto-apply so HA text entry does not spam flash writes
      - lambda: 'id(sht30_cal_pending) = true;'
      - script.execute: sht30_debounced_apply_single_point_cal

# --- One-click SHT30 calibration + reset ---
button:
  - platform: template
    id: sht30_calibrate_now
    name: "${friendly_name} Calibrate SHT30 Now"
    on_press:
      - script.execute: sht30_apply_single_point_cal

  - platform: template
    id: sht30_reset_cal
    name: "${friendly_name} Reset SHT30 Calibration"
    on_press:
      - lambda: |-
          id(sht30_dt_committed)   = 0.0f;
          id(sht30_rh_b_committed) = 0.0f;
          ESP_LOGI("sht30_cal", "Calibration reset: ΔT=0.00, b=0.00");
      - lambda: |-
          // Force immediate recompute of calibrated copies
          if (id(sht30_temp_raw).has_state()) id(sht30_temp_raw).publish_state(id(sht30_temp_raw).state);
          if (id(sht30_rh_raw).has_state())   id(sht30_rh_raw).publish_state(id(sht30_rh_raw).state);

# --- Single-point calibration script (offset-only; commits to flash) ---
script:
  # Debounced wrapper to avoid repeated commits while typing reference values
  - id: sht30_debounced_apply_single_point_cal
    mode: restart
    then:
      - delay: 750ms
      - script.execute: sht30_apply_single_point_cal

  - id: sht30_apply_single_point_cal
    then:
      - lambda: |-
          if (!id(sht30_temp_raw).has_state() || !id(sht30_rh_raw).has_state()) {
            ESP_LOGW("sht30_cal", "Raw SHT30 readings not ready yet.");
            id(sht30_cal_pending) = true;
            return;
          }
          const float t_ref  = id(sht30_ref_t).state;
          const float rh_ref = id(sht30_ref_rh).state;
          const float t_raw  = id(sht30_temp_raw).state;
          const float rh_raw = id(sht30_rh_raw).state;

          // Compute offsets
          float dt = t_ref - t_raw;     // °C
          float b  = rh_ref - rh_raw;   // %RH

          // Clamp to safe ranges
          if (dt < -30.0f) dt = -30.0f;
          if (dt >  30.0f) dt =  30.0f;
          if (b  < -50.0f) b  = -50.0f;
          if (b  >  50.0f) b  =  50.0f;

          // Commit to flash-backed globals
          id(sht30_dt_committed)   = dt;
          id(sht30_rh_b_committed) = b;
          id(sht30_cal_pending)    = false;

          ESP_LOGI("sht30_cal",
                   "Committed SHT30 calibration: ΔT=%.2f °C, b=%.2f %% (raw T=%.2f °C RH=%.1f %%; ref T=%.2f °C RH=%.1f %%)",
                   dt, b, t_raw, rh_raw, t_ref, rh_ref);

          // Force immediate recompute of calibrated copies
          id(sht30_temp_raw).publish_state(id(sht30_temp_raw).state);
          id(sht30_rh_raw).publish_state(id(sht30_rh_raw).state);

# --- One-time SCD4x forced calibration at boot (426 ppm) ---
esphome:
  on_boot:
    priority: -100
    then:
      - if:
          condition:
            lambda: 'return !id(scd4x_cal_done);'
          then:
            - delay: 30s
            - scd4x.perform_forced_calibration:
                id: scd4x_sensor
                value: 426
            - lambda: |-
                id(scd4x_cal_done) = true;

sensor:
  # -------- SEN55 (PM + VOC/NOx + T/H) ----------
  - platform: sen5x
    id: sen55
    i2c_id: i2c0

    pm_1_0:
      id: pm_1_0
      name: "PM1.0"
      accuracy_decimals: 1
      on_value: { then: [ script.execute: mini_update_4leds ] }

    pm_2_5:
      id: pm_2_5
      name: "PM2.5"
      accuracy_decimals: 1
      on_value: { then: [ script.execute: mini_update_4leds ] }

    pm_4_0:
      id: pm_4_0
      name: "PM4.0"
      accuracy_decimals: 1
      on_value: { then: [ script.execute: mini_update_4leds ] }

    pm_10_0:
      id: pm_10_0
      name: "PM10"
      accuracy_decimals: 1
      on_value: { then: [ script.execute: mini_update_4leds ] }

    temperature:
      id: aqi_temp
      name: "Temperature"
      accuracy_decimals: 1

    humidity:
      id: aqi_humidity
      name: "Humidity"
      accuracy_decimals: 0

    voc:
      id: voc_index
      name: "VOC Index"
      on_value: { then: [ script.execute: mini_update_4leds ] }

    nox:
      id: nox_index
      name: "NOx Index"
      on_value: { then: [ script.execute: mini_update_4leds ] }

    update_interval: 10s

  # -------- SCD4x (CO₂) ----------
  - platform: scd4x
    id: scd4x_sensor
    i2c_id: i2c0
    measurement_mode: periodic
    automatic_self_calibration: true
    co2:
      id: scd40_co2
      internal: true
      on_value: { then: [ script.execute: mini_update_4leds ] }

  # CO₂ display (never Unknown)
  - platform: template
    id: co2_display
    name: "CO₂"
    unit_of_measurement: "ppm"
    device_class: carbon_dioxide
    state_class: measurement
    accuracy_decimals: 0
    update_interval: 5s
    lambda: |-
      static float last_valid = NAN;
      float v = id(scd40_co2).state;
      if (!std::isnan(v)) last_valid = v;
      if (std::isnan(last_valid)) return id(co2_display).state;
      return last_valid;

  # -------- SHT30 (raw hidden) ----------
  - platform: sht3xd
    i2c_id: i2c0
    address: 0x44
    update_interval: 30s
    heater_enabled: false
    temperature:
      id: sht30_temp_raw
      internal: true
      accuracy_decimals: 2
      on_value:
        - if:
            condition:
              lambda: 'return id(sht30_cal_pending);'
            then:
              - script.execute: sht30_apply_single_point_cal
    humidity:
      id: sht30_rh_raw
      internal: true
      accuracy_decimals: 1
      on_value:
        - if:
            condition:
              lambda: 'return id(sht30_cal_pending);'
            then:
              - script.execute: sht30_apply_single_point_cal

  # Calibrated SHT30 Temperature = raw + committed ΔT
  - platform: copy
    source_id: sht30_temp_raw
    name: "SHT30 Temperature"
    device_class: temperature
    state_class: measurement
    unit_of_measurement: "°C"
    accuracy_decimals: 2
    filters:
      - median: { window_size: 7, send_every: 1, send_first_at: 1 }
      - lambda: |-
          // Calibrated copy stays bound to the committed ΔT offset
          return x + id(sht30_dt_committed);

  # Calibrated SHT30 Humidity = raw + committed b, clamped 0–100%
  - platform: copy
    source_id: sht30_rh_raw
    name: "SHT30 Humidity"
    device_class: humidity
    state_class: measurement
    unit_of_measurement: "%"
    accuracy_decimals: 1
    filters:
      - median: { window_size: 7, send_every: 1, send_first_at: 1 }
      - lambda: |-
          // Calibrated copy stays bound to the committed humidity offset
          float y = x + id(sht30_rh_b_committed);
          if (y < 0.0f)   y = 0.0f;
          if (y > 100.0f) y = 100.0f;
          return y;

  # -------- LTR303 (ALS) ----------
  - platform: ltr_als_ps
    i2c_id: i2c0
    ambient_light:
      id: ambient_lux
      name: "Illuminance"

text_sensor:
  - platform: template
    id: co2_status
    name: "CO₂ Status"
    update_interval: 5s
    icon: mdi:molecule-co2
    lambda: |-
      if (std::isnan(id(scd40_co2).state)) return std::string("Heating up");
      const float co2 = id(scd40_co2).state;
      if (co2 < id(g_co2_good))           return std::string("Good");
      else if (co2 < id(g_co2_moderate))  return std::string("Moderate");
      else if (co2 < id(g_co2_unhealthy)) return std::string("Unhealthy");
      else                                return std::string("High");
