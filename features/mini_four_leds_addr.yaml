# Mini: 4 addressable LEDs on one pin (WS2812/NeoPixel etc.)
# LED 0 = PM (SEN55 PM2.5), LED 1 = VOC (SEN55 VOC index),
# LED 2 = NOx (SEN55 NOx index), LED 3 = CO₂ (SCD4x via co2_display)
# Colors per sensor state:
#   Good = Green, Moderate = Orange, Unhealthy = Red, Poor = Purple

# Requires substitutions in your main YAML:
#   led_data_pin: <GPIO>
#   led_count: "4"
#   led_chipset: ws2812
#   led_rgb_order: GRB
#
# Requires the following IDs to exist (from airiq_mini_profile.yaml):
#   pm_2_5, voc_index, nox_index, co2_display
#   g_pm25_good/g_pm25_moderate/g_pm25_unhealthy
#   g_voc_good/g_voc_moderate/g_voc_unhealthy
#   g_nox_good/g_nox_moderate/g_nox_unhealthy
#   g_co2_good/g_co2_moderate/g_co2_unhealthy

light:
  - platform: esp32_rmt_led_strip
    id: mini_led_strip
    name: "${friendly_name} Mini LED Strip"
    pin: ${led_data_pin}
    num_leds: ${led_count}
    chipset: ${led_chipset}
    rgb_order: ${led_rgb_order}
    restore_mode: ALWAYS_OFF
    effects:
      - addressable_lambda:
          name: "AirIQ 4-LED Status"
          update_interval: 1s
          lambda: |-
            const int LEVEL_UNKNOWN = -1;

            // Map 0=Good, 1=Moderate, 2=Unhealthy, 3=Poor, -1=Unknown
            // Unknown -> dim blue/gray, Good -> Green, Moderate -> Orange,
            // Unhealthy -> Red, Poor -> Purple
            auto color_for = [&](int level) -> Color {
              switch (level) {
                case LEVEL_UNKNOWN: return Color(24, 32, 64);   // Unknown (off/gray/blue)
                case 0:              return Color(0, 255, 0);   // Green
                case 1:              return Color(255, 128, 0); // Orange
                case 2:              return Color(255, 0, 0);   // Red
                default:             return Color(128, 0, 255); // Purple
              }
            };

            // --- PM (use PM2.5)
            int lvl_pm = LEVEL_UNKNOWN;
            if (id(pm_2_5).has_state()) {
              const float v = id(pm_2_5).state;
              if (v < id(g_pm25_good))            lvl_pm = 0;
              else if (v < id(g_pm25_moderate))   lvl_pm = 1;
              else if (v < id(g_pm25_unhealthy))  lvl_pm = 2;
              else                                 lvl_pm = 3;
            }

            // --- VOC index
            int lvl_voc = LEVEL_UNKNOWN;
            if (id(voc_index).has_state()) {
              const float v = id(voc_index).state;
              if (v < id(g_voc_good))            lvl_voc = 0;
              else if (v < id(g_voc_moderate))   lvl_voc = 1;
              else if (v < id(g_voc_unhealthy))  lvl_voc = 2;
              else                                lvl_voc = 3;
            }

            // --- NOx index
            int lvl_nox = LEVEL_UNKNOWN;
            if (id(nox_index).has_state()) {
              const float v = id(nox_index).state;
              if (v < id(g_nox_good))            lvl_nox = 0;
              else if (v < id(g_nox_moderate))   lvl_nox = 1;
              else if (v < id(g_nox_unhealthy))  lvl_nox = 2;
              else                                lvl_nox = 3;
            }

            // --- CO2 (ppm) via co2_display (never "Unknown")
            int lvl_co2 = LEVEL_UNKNOWN;
            if (id(co2_display).has_state()) {
              const float v = id(co2_display).state;
              if (v < id(g_co2_good))            lvl_co2 = 0;
              else if (v < id(g_co2_moderate))   lvl_co2 = 1;
              else if (v < id(g_co2_unhealthy))  lvl_co2 = 2;
              else                                lvl_co2 = 3;
            }

            const Color unknown_color = color_for(LEVEL_UNKNOWN);
            if (it.size() < 4) {
              it.fill(unknown_color);  // need 4 pixels
              return;
            }
            it[0] = color_for(lvl_pm);   // PM
            it[1] = color_for(lvl_voc);  // VOC
            it[2] = color_for(lvl_nox);  // NOx
            it[3] = color_for(lvl_co2);  // CO₂

# Call this from sensors on_value to ensure the strip is on with the correct effect.
script:
  - id: mini_update_4leds
    mode: restart
    then:
      - light.turn_on:
          id: mini_led_strip
          effect: "AirIQ 4-LED Status"

# Optional: turn on the effect at boot so LEDs reflect status immediately.
# comment out if you don't want LEDs on by default.
esphome:
  on_boot:
    priority: -10
    then:
      - light.turn_on:
          id: mini_led_strip
          effect: "AirIQ 4-LED Status"
          brightness: 50%
