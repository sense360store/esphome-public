# Mini: 4 addressable LEDs on one pin (WS2812/NeoPixel etc.)
# LED 0 = PM (SEN55 PM2.5), LED 1 = VOC (SEN55 VOC index),
# LED 2 = NOx (SEN55 NOx index), LED 3 = CO₂ (SCD4x via co2_display)
# Colors per sensor state: Green = Good, Orange = Moderate, Red = Unhealthy

# Requires substitutions in your main YAML:
#   led_data_pin: <GPIO>
#   led_count: "4"
#   led_chipset: ws2812
#   led_rgb_order: GRB
#
# Requires the following IDs to exist (from airiq_mini_profile.yaml):
#   pm_2_5, voc_index, nox_index, co2_display
#   g_pm25_good/g_pm25_moderate/g_pm25_unhealthy
#   g_voc_good/g_voc_moderate/g_voc_unhealthy
#   g_nox_good/g_nox_moderate/g_nox_unhealthy
#   g_co2_good/g_co2_moderate/g_co2_unhealthy

light:
  - platform: esp32_rmt_led_strip
    id: mini_led_strip
    name: "${friendly_name} Mini LED Strip"
    pin: ${led_data_pin}
    num_leds: ${led_count}
    chipset: ${led_chipset}
    rgb_order: ${led_rgb_order}
    restore_mode: ALWAYS_OFF
    effects:
      - addressable_lambda:
          name: "AirIQ 4-LED Status"
          update_interval: 1s
          lambda: |-
            // Map 0=Good, 1=Moderate, 2=Unhealthy -> Green/Orange/Red
            auto color_for = [&](int level) -> Color {
              if (level >= 2) return Color(255, 0, 0);       // Red
              if (level == 1) return Color(255, 128, 0);     // Orange
              return Color(0, 255, 0);                       // Green
            };

            // --- PM (use PM2.5)
            int lvl_pm = 0;
            if (id(pm_2_5).has_state()) {
              const float v = id(pm_2_5).state;
              if (v >= id(g_pm25_unhealthy))      lvl_pm = 2;
              else if (v >= id(g_pm25_moderate))  lvl_pm = 1;
              else                                 lvl_pm = 0;
            }

            // --- VOC index
            int lvl_voc = 0;
            if (id(voc_index).has_state()) {
              const float v = id(voc_index).state;
              if (v >= id(g_voc_unhealthy))      lvl_voc = 2;
              else if (v >= id(g_voc_moderate))  lvl_voc = 1;
              else                                lvl_voc = 0;
            }

            // --- NOx index
            int lvl_nox = 0;
            if (id(nox_index).has_state()) {
              const float v = id(nox_index).state;
              if (v >= id(g_nox_unhealthy))      lvl_nox = 2;
              else if (v >= id(g_nox_moderate))  lvl_nox = 1;
              else                                lvl_nox = 0;
            }

            // --- CO2 (ppm) via co2_display (never "Unknown")
            int lvl_co2 = 0;
            if (id(co2_display).has_state()) {
              const float v = id(co2_display).state;
              if (v >= id(g_co2_unhealthy))      lvl_co2 = 2;
              else if (v >= id(g_co2_moderate))  lvl_co2 = 1;
              else                                lvl_co2 = 0;
            }

            if (it.size() < 4) return;  // need 4 pixels
            it[0] = color_for(lvl_pm);   // PM
            it[1] = color_for(lvl_voc);  // VOC
            it[2] = color_for(lvl_nox);  // NOx
            it[3] = color_for(lvl_co2);  // CO₂

# Call this from sensors on_value to ensure the strip is on with the correct effect.
script:
  - id: mini_update_4leds
    mode: restart
    then:
      - light.turn_on:
          id: mini_led_strip
          effect: "AirIQ 4-LED Status"

# Optional: turn on the effect at boot so LEDs reflect status immediately.
# comment out if you don't want LEDs on by default.
esphome:
  on_boot:
    priority: -10
    then:
      - light.turn_on:
          id: mini_led_strip
          effect: "AirIQ 4-LED Status"
          brightness: 50%
