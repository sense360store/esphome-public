# Mini: 4 addressable LEDs on one pin (WS2812/NeoPixel etc.)
# LED 0 = PM (SEN55 PM2.5), LED 1 = VOC (SEN55 VOC index),
# LED 2 = NOx (SEN55 NOx index), LED 3 = CO₂ (SCD4x via co2_display)
# Colors per sensor state:
#   Good = Green, Moderate = Orange, Unhealthy = Red, Poor = Purple

# Requires substitutions in your main YAML (defaults provided):
#   led_data_pin: <GPIO>
#   led_count: "4"
#   led_chipset: ws2812
#   led_rgb_order: GRB
#   night_mode_enabled: "true"       # Enable time-based dimming/off
#   night_brightness: "0.05"         # 0.0-1.0 brightness for night mode
#   night_mode_start_hour: "22"
#   night_mode_start_minute: "0"
#   night_mode_end_hour: "7"
#   night_mode_end_minute: "0"
#   night_light_enabled: "true"     # Enable presence-activated night light
#
# Requires the following IDs to exist (from airiq_mini_profile.yaml):
#   pm_1_0, pm_2_5, pm_4_0, pm_10_0, voc_index, nox_index, co2_display
#   g_pm1_good/g_pm1_moderate/g_pm1_unhealthy
#   g_pm25_good/g_pm25_moderate/g_pm25_unhealthy
#   g_pm40_good/g_pm40_moderate/g_pm40_unhealthy
#   g_pm10_good/g_pm10_moderate/g_pm10_unhealthy
#   g_voc_good/g_voc_moderate/g_voc_unhealthy
#   g_nox_good/g_nox_moderate/g_nox_unhealthy
#   g_co2_good/g_co2_moderate/g_co2_unhealthy

substitutions:
  night_mode_enabled: "true"
  night_brightness: "0.05"
  night_mode_start_hour: "22"
  night_mode_start_minute: "0"
  night_mode_end_hour: "7"
  night_mode_end_minute: "0"
  night_light_enabled: "true"

globals:
  - id: mini_night_mode_enabled
    type: bool
    restore_value: true
    initial_value: ${night_mode_enabled}

  - id: mini_night_inactivity_seconds
    type: int
    restore_value: true
    initial_value: '30'

  - id: mini_night_mode_override
    type: int
    restore_value: true
    initial_value: '0'  # 0=auto, 1=force day, 2=force night

  - id: mini_night_brightness
    type: float
    restore_value: true
    initial_value: ${night_brightness}

  - id: mini_is_night_mode_now
    type: bool
    restore_value: false
    initial_value: 'false'

  - id: mini_night_light_enabled
    type: bool
    restore_value: true
    initial_value: ${night_light_enabled}

  - id: mini_last_presence_state
    type: int
    restore_value: false
    initial_value: '-1'  # -1=unknown, 0=absent, 1=present

light:
  - platform: esp32_rmt_led_strip
    id: mini_led_strip
    name: "${friendly_name} Mini LED Strip"
    pin: ${led_data_pin}
    num_leds: ${led_count}
    chipset: ${led_chipset}
    rgb_order: ${led_rgb_order}
    restore_mode: ALWAYS_OFF
    effects:
      - addressable_lambda:
          name: "AirIQ 4-LED Status"
          update_interval: 1s
          lambda: |-
            const int LEVEL_UNKNOWN = -1;

            // Map 0=Good, 1=Moderate, 2=Unhealthy, 3=Poor, -1=Unknown
            // Unknown -> dim blue/gray, Good -> Green, Moderate -> Orange,
            // Unhealthy -> Red, Poor -> Purple
            auto color_for = [&](int level) -> Color {
              switch (level) {
                case LEVEL_UNKNOWN: return Color(24, 32, 64);   // Unknown (off/gray/blue)
                case 0:              return Color(0, 255, 0);   // Green
                case 1:              return Color(255, 128, 0); // Orange
                case 2:              return Color(255, 0, 0);   // Red
                default:             return Color(128, 0, 255); // Purple
              }
            };

            auto scale_color = [&](Color c, float scale) -> Color {
              return Color(uint8_t(c.red * scale),
                           uint8_t(c.green * scale),
                           uint8_t(c.blue * scale));
            };

            // --- PM (use worst tier across available PM1/2.5/4/10)
            auto pm_level_for = [&](Sensor *sensor, float good, float moderate, float unhealthy) -> int {
              if (sensor == nullptr || !sensor->has_state()) return LEVEL_UNKNOWN;

              const float v = sensor->state;
              if (v < good)           return 0;
              else if (v < moderate)  return 1;
              else if (v < unhealthy) return 2;
              else                    return 3;
            };

            const int lvl_pm_1_0  = pm_level_for(id(pm_1_0),  id(g_pm1_good),  id(g_pm1_moderate),  id(g_pm1_unhealthy));
            const int lvl_pm_2_5  = pm_level_for(id(pm_2_5),  id(g_pm25_good), id(g_pm25_moderate), id(g_pm25_unhealthy));
            const int lvl_pm_4_0  = pm_level_for(id(pm_4_0),  id(g_pm40_good), id(g_pm40_moderate), id(g_pm40_unhealthy));
            const int lvl_pm_10_0 = pm_level_for(id(pm_10_0), id(g_pm10_good), id(g_pm10_moderate), id(g_pm10_unhealthy));

            const int lvl_pm = std::max(std::max(lvl_pm_1_0, lvl_pm_2_5), std::max(lvl_pm_4_0, lvl_pm_10_0));

            // --- VOC index
            int lvl_voc = LEVEL_UNKNOWN;
            if (id(voc_index).has_state()) {
              const float v = id(voc_index).state;
              if (v < id(g_voc_good))            lvl_voc = 0;
              else if (v < id(g_voc_moderate))   lvl_voc = 1;
              else if (v < id(g_voc_unhealthy))  lvl_voc = 2;
              else                                lvl_voc = 3;
            }

            // --- NOx index
            int lvl_nox = LEVEL_UNKNOWN;
            if (id(nox_index).has_state()) {
              const float v = id(nox_index).state;
              if (v < id(g_nox_good))            lvl_nox = 0;
              else if (v < id(g_nox_moderate))   lvl_nox = 1;
              else if (v < id(g_nox_unhealthy))  lvl_nox = 2;
              else                                lvl_nox = 3;
            }

            // --- CO2 (ppm) via co2_display (never "Unknown")
            int lvl_co2 = LEVEL_UNKNOWN;
            if (id(co2_display).has_state()) {
              const float v = id(co2_display).state;
              if (v < id(g_co2_good))            lvl_co2 = 0;
              else if (v < id(g_co2_moderate))   lvl_co2 = 1;
              else if (v < id(g_co2_unhealthy))  lvl_co2 = 2;
              else                                lvl_co2 = 3;
            }

            const int max_lvl = std::max(std::max(lvl_pm, lvl_voc), std::max(lvl_nox, lvl_co2));
            const float brightness_scale =
              (max_lvl == 0) ? 0.40f :
              (max_lvl == 1) ? 0.60f :
              (max_lvl == 2) ? 0.80f :
                                 1.00f;

            if (it.size() < 4) return;  // need 4 pixels
            it[0] = scale_color(color_for(lvl_pm), brightness_scale);   // PM
            it[1] = scale_color(color_for(lvl_voc), brightness_scale);  // VOC
            it[2] = scale_color(color_for(lvl_nox), brightness_scale);  // NOx
            it[3] = scale_color(color_for(lvl_co2), brightness_scale);  // CO₂

switch:
  - platform: template
    id: mini_night_mode_switch
    name: "${friendly_name} Night Mode"
    entity_category: config
    restore_mode: RESTORE_DEFAULT_OFF
    lambda: |-
      return id(mini_night_mode_enabled);
    turn_on_action:
      - lambda: |-
          id(mini_night_mode_enabled) = true;
      - script.execute: mini_refresh_night_mode
    turn_off_action:
      - lambda: |-
          id(mini_night_mode_enabled) = false;
      - script.execute: mini_refresh_night_mode

  - platform: template
    id: mini_night_light_switch
    name: "${friendly_name} Night Light"
    entity_category: config
    restore_mode: RESTORE_DEFAULT_OFF
    lambda: |-
      return id(mini_night_light_enabled);
    turn_on_action:
      - lambda: |-
          id(mini_night_light_enabled) = true;
      - script.execute: mini_apply_led_state
    turn_off_action:
      - lambda: |-
          id(mini_night_light_enabled) = false;
      - script.execute: mini_apply_led_state

select:
  - platform: template
    id: mini_night_mode_override_select
    name: "${friendly_name} Night Mode Override"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_option: "Auto"
    options:
      - "Auto"
      - "Force Off"
      - "Force On"
    set_action:
      - lambda: |-
          int override = 0;
          if (x == "Force Off")      override = 1;
          else if (x == "Force On") override = 2;
          id(mini_night_mode_override) = override;
      - script.execute: mini_refresh_night_mode

number:
  - platform: template
    id: mini_night_brightness_number
    name: "${friendly_name} Night Brightness"
    entity_category: config
    min_value: 0.0
    max_value: 1.0
    step: 0.01
    lambda: |-
      return id(mini_night_brightness);
    set_action:
      - lambda: |-
          id(mini_night_brightness) = x;
      - script.execute: mini_apply_led_state

  - platform: template
    id: mini_night_inactivity_timeout
    name: "${friendly_name} Night Inactivity Timeout"
    entity_category: config
    unit_of_measurement: s
    min_value: 5
    max_value: 300
    step: 5
    lambda: |-
      return id(mini_night_inactivity_seconds);
    set_action:
      - lambda: |-
          id(mini_night_inactivity_seconds) = (int) x;

interval:
  - interval: 1s
    then:
      - lambda: |-
          if (!id(mini_night_light_enabled)) {
            id(mini_last_presence_state) = -1;
            return;
          }

          if (!id(mini_is_night_mode_now)) {
            id(mini_last_presence_state) = -1;
            return;
          }

          if (!id(presence_occupied).has_state()) {
            return;
          }

          const int current_presence = id(presence_occupied).state ? 1 : 0;
          if (current_presence != id(mini_last_presence_state)) {
            id(mini_last_presence_state) = current_presence;

            if (current_presence == 1) {
              id(mini_handle_night_presence_on).execute();
            } else {
              id(mini_handle_night_presence_off).execute();
            }
          }

  - interval: 1min
    then:
      - script.execute: mini_refresh_night_mode

# Call this from sensors on_value to ensure the strip follows the correct mode/effect.
script:
  - id: mini_apply_led_state
    mode: restart
    then:
      - if:
          condition:
            lambda: |-
              return id(mini_is_night_mode_now);
          then:
            - if:
                condition:
                  lambda: |-
                    return id(mini_night_light_enabled);
                then:
                  - lambda: |-
                      if (id(presence_occupied).has_state()) {
                        id(mini_last_presence_state) = id(presence_occupied).state ? 1 : 0;
                      } else {
                        id(mini_last_presence_state) = -1;
                      }
                  - if:
                      condition:
                        lambda: |-
                          return id(presence_occupied).has_state() && id(presence_occupied).state;
                      then:
                        - script.execute: mini_handle_night_presence_on
                      else:
                        - script.execute: mini_handle_night_presence_off
                else:
                  - lambda: |-
                      id(mini_last_presence_state) = -1;

                      const float night_brightness = ${night_brightness};
                      if (night_brightness <= 0.0001f) {
                        id(mini_led_strip).turn_off();
                        return;
                      }

                      auto call = id(mini_led_strip).turn_on();
                      call.set_effect("AirIQ 4-LED Status");
                      call.set_brightness(night_brightness);
                      call.perform();
          else:
            - lambda: |-
                id(mini_last_presence_state) = -1;
                auto call = id(mini_led_strip).turn_on();
                call.set_effect("AirIQ 4-LED Status");
                call.perform();

  - id: mini_refresh_night_mode
    mode: restart
    then:
      - lambda: |-
          bool should_be_night = false;
          const int override = id(mini_night_mode_override);
          if (override == 2) {
            should_be_night = true;
          } else if (override == 1) {
            should_be_night = false;
          } else if (id(mini_night_mode_enabled)) {
            auto now = id(homeassistant_time).now();
            if (now.is_valid()) {
              const int start_minutes = ${night_mode_start_hour} * 60 + ${night_mode_start_minute};
              const int end_minutes   = ${night_mode_end_hour} * 60 + ${night_mode_end_minute};
              const int cur_minutes   = now.hour * 60 + now.minute;

              if (start_minutes <= end_minutes) {
                should_be_night = (cur_minutes >= start_minutes && cur_minutes < end_minutes);
              } else {
                should_be_night = (cur_minutes >= start_minutes || cur_minutes < end_minutes);
              }
            }
          }

          id(mini_is_night_mode_now) = should_be_night;
      - script.execute: mini_apply_led_state

  - id: mini_update_4leds
    mode: restart
    then:
      - script.execute: mini_refresh_night_mode

  - id: mini_handle_night_presence_on
    mode: restart
    then:
      - lambda: |-
          if (!id(mini_night_light_enabled)) return;
          if (!id(mini_is_night_mode_now)) return;

          const float night_brightness = id(mini_night_brightness);
          if (night_brightness <= 0.0001f) {
            id(mini_led_strip).turn_off();
          } else {
            auto call = id(mini_led_strip).turn_on();
            call.set_transition_length(500);
            call.set_effect("None");
            call.set_brightness(night_brightness);
            call.set_rgb(1.0f, 1.0f, 1.0f);
            call.perform();
          }
      - script.execute: mini_night_inactivity_timer

  - id: mini_handle_night_presence_off
    mode: restart
    then:
      - lambda: |-
          if (!id(mini_night_light_enabled)) return;
      - script.execute: mini_night_inactivity_timer

  - id: mini_night_inactivity_timer
    mode: restart
    then:
      - delay: !lambda |-
          return (uint32_t) (id(mini_night_inactivity_seconds) * 1000);
      - lambda: |-
          if (!id(mini_is_night_mode_now)) return;

          if (id(presence_occupied).has_state() && id(presence_occupied).state) {
            return;
          }

          auto call = id(mini_led_strip).turn_off();
          call.set_transition_length(500);
          call.perform();

text_sensor:
  # Highest severity pollutant (mini MVP)
  - platform: template
    id: mini_mvp_pollutant
    name: "${friendly_name} MVP Pollutant"
    icon: mdi:alert-circle-outline
    update_interval: 10s
    lambda: |-
      auto severity_for = [](float value, float good, float moderate, float unhealthy) -> int {
        if (value < good)          return 0;
        else if (value < moderate) return 1;
        else if (value < unhealthy) return 2;
        else                        return 3;
      };

      int worst_level = -1;
      const char *worst_name = "Unknown";

      if (id(pm_2_5).has_state()) {
        const int lvl = severity_for(id(pm_2_5).state, id(g_pm25_good), id(g_pm25_moderate), id(g_pm25_unhealthy));
        if (lvl > worst_level) { worst_level = lvl; worst_name = "PM2.5"; }
      }

      if (id(voc_index).has_state()) {
        const int lvl = severity_for(id(voc_index).state, id(g_voc_good), id(g_voc_moderate), id(g_voc_unhealthy));
        if (lvl > worst_level) { worst_level = lvl; worst_name = "VOC"; }
      }

      if (id(nox_index).has_state()) {
        const int lvl = severity_for(id(nox_index).state, id(g_nox_good), id(g_nox_moderate), id(g_nox_unhealthy));
        if (lvl > worst_level) { worst_level = lvl; worst_name = "NOx"; }
      }

      if (id(co2_display).has_state()) {
        const int lvl = severity_for(id(co2_display).state, id(g_co2_good), id(g_co2_moderate), id(g_co2_unhealthy));
        if (lvl > worst_level) { worst_level = lvl; worst_name = "CO₂"; }
      }

      return std::string(worst_name);

  - platform: template
    id: mini_mvp_severity
    name: "${friendly_name} MVP Severity"
    icon: mdi:alpha-s-circle-outline
    update_interval: 10s
    lambda: |-
      auto severity_for = [](float value, float good, float moderate, float unhealthy) -> int {
        if (value < good)          return 0;
        else if (value < moderate) return 1;
        else if (value < unhealthy) return 2;
        else                        return 3;
      };

      int worst_level = -1;

      if (id(pm_2_5).has_state()) {
        worst_level = std::max(worst_level, severity_for(id(pm_2_5).state, id(g_pm25_good), id(g_pm25_moderate), id(g_pm25_unhealthy)));
      }
      if (id(voc_index).has_state()) {
        worst_level = std::max(worst_level, severity_for(id(voc_index).state, id(g_voc_good), id(g_voc_moderate), id(g_voc_unhealthy)));
      }
      if (id(nox_index).has_state()) {
        worst_level = std::max(worst_level, severity_for(id(nox_index).state, id(g_nox_good), id(g_nox_moderate), id(g_nox_unhealthy)));
      }
      if (id(co2_display).has_state()) {
        worst_level = std::max(worst_level, severity_for(id(co2_display).state, id(g_co2_good), id(g_co2_moderate), id(g_co2_unhealthy)));
      }

      switch (worst_level) {
        case 0: return std::string("Good");
        case 1: return std::string("Moderate");
        case 2: return std::string("Unhealthy");
        case 3: return std::string("Poor");
        default: return std::string("Unknown");
      }

# Optional: turn on the effect at boot so LEDs reflect status immediately.
# comment out if you don't want LEDs on by default.
esphome:
  on_boot:
    priority: -10
    then:
      - script.execute: mini_refresh_night_mode
