# Mini: 4 addressable LEDs on one pin (WS2812/NeoPixel etc.)
# LED 0 = PM (SEN55 PM2.5), LED 1 = VOC (SEN55 VOC index),
# LED 2 = NOx (SEN55 NOx index), LED 3 = CO₂ (SCD4x via co2_display)
# Colors per sensor state:
#   Good = Green, Moderate = Orange, Unhealthy = Red, Poor = Purple

# Requires substitutions in your main YAML (defaults provided):
#   led_data_pin: <GPIO>
#   led_count: "4"
#   led_chipset: ws2812
#   led_rgb_order: GRB
#   night_mode_enabled: "true"       # Enable time-based dimming/off
#   night_brightness: "0.05"         # 0.0-1.0 brightness for night mode
#   night_mode_start_hour: "22"
#   night_mode_start_minute: "0"
#   night_mode_end_hour: "7"
#   night_mode_end_minute: "0"
#
# Requires the following IDs to exist (from airiq_mini_profile.yaml):
#   pm_2_5, voc_index, nox_index, co2_display
#   g_pm25_good/g_pm25_moderate/g_pm25_unhealthy
#   g_voc_good/g_voc_moderate/g_voc_unhealthy
#   g_nox_good/g_nox_moderate/g_nox_unhealthy
#   g_co2_good/g_co2_moderate/g_co2_unhealthy

substitutions:
  night_mode_enabled: "true"
  night_brightness: "0.05"
  night_mode_start_hour: "22"
  night_mode_start_minute: "0"
  night_mode_end_hour: "7"
  night_mode_end_minute: "0"

globals:
  - id: mini_night_mode_enabled
    type: bool
    restore_value: true
    initial_value: ${night_mode_enabled}

  - id: mini_night_mode_override
    type: int
    restore_value: true
    initial_value: '0'  # 0=auto, 1=force day, 2=force night

  - id: mini_is_night_mode_now
    type: bool
    restore_value: false
    initial_value: 'false'

light:
  - platform: esp32_rmt_led_strip
    id: mini_led_strip
    name: "${friendly_name} Mini LED Strip"
    pin: ${led_data_pin}
    num_leds: ${led_count}
    chipset: ${led_chipset}
    rgb_order: ${led_rgb_order}
    restore_mode: ALWAYS_OFF
    effects:
      - addressable_lambda:
          name: "AirIQ 4-LED Status"
          update_interval: 1s
          lambda: |-
            const int LEVEL_UNKNOWN = -1;

            // Map 0=Good, 1=Moderate, 2=Unhealthy, 3=Poor, -1=Unknown
            // Unknown -> dim blue/gray, Good -> Green, Moderate -> Orange,
            // Unhealthy -> Red, Poor -> Purple
            auto color_for = [&](int level) -> Color {
              switch (level) {
                case LEVEL_UNKNOWN: return Color(24, 32, 64);   // Unknown (off/gray/blue)
                case 0:              return Color(0, 255, 0);   // Green
                case 1:              return Color(255, 128, 0); // Orange
                case 2:              return Color(255, 0, 0);   // Red
                default:             return Color(128, 0, 255); // Purple
              }
            };

            auto scale_color = [&](Color c, float scale) -> Color {
              return Color(uint8_t(c.red * scale),
                           uint8_t(c.green * scale),
                           uint8_t(c.blue * scale));
            };

            // --- PM (use PM2.5)
            int lvl_pm = LEVEL_UNKNOWN;
            if (id(pm_2_5).has_state()) {
              const float v = id(pm_2_5).state;
              if (v < id(g_pm25_good))            lvl_pm = 0;
              else if (v < id(g_pm25_moderate))   lvl_pm = 1;
              else if (v < id(g_pm25_unhealthy))  lvl_pm = 2;
              else                                 lvl_pm = 3;
            }

            // --- VOC index
            int lvl_voc = LEVEL_UNKNOWN;
            if (id(voc_index).has_state()) {
              const float v = id(voc_index).state;
              if (v < id(g_voc_good))            lvl_voc = 0;
              else if (v < id(g_voc_moderate))   lvl_voc = 1;
              else if (v < id(g_voc_unhealthy))  lvl_voc = 2;
              else                                lvl_voc = 3;
            }

            // --- NOx index
            int lvl_nox = LEVEL_UNKNOWN;
            if (id(nox_index).has_state()) {
              const float v = id(nox_index).state;
              if (v < id(g_nox_good))            lvl_nox = 0;
              else if (v < id(g_nox_moderate))   lvl_nox = 1;
              else if (v < id(g_nox_unhealthy))  lvl_nox = 2;
              else                                lvl_nox = 3;
            }

            // --- CO2 (ppm) via co2_display (never "Unknown")
            int lvl_co2 = LEVEL_UNKNOWN;
            if (id(co2_display).has_state()) {
              const float v = id(co2_display).state;
              if (v < id(g_co2_good))            lvl_co2 = 0;
              else if (v < id(g_co2_moderate))   lvl_co2 = 1;
              else if (v < id(g_co2_unhealthy))  lvl_co2 = 2;
              else                                lvl_co2 = 3;
            }

            const int max_lvl = std::max(std::max(lvl_pm, lvl_voc), std::max(lvl_nox, lvl_co2));
            const float brightness_scale =
              (max_lvl == 0) ? 0.40f :
              (max_lvl == 1) ? 0.60f :
              (max_lvl == 2) ? 0.80f :
                                 1.00f;

            if (it.size() < 4) return;  // need 4 pixels
            it[0] = scale_color(color_for(lvl_pm), brightness_scale);   // PM
            it[1] = scale_color(color_for(lvl_voc), brightness_scale);  // VOC
            it[2] = scale_color(color_for(lvl_nox), brightness_scale);  // NOx
            it[3] = scale_color(color_for(lvl_co2), brightness_scale);  // CO₂

switch:
  - platform: template
    id: mini_night_mode_switch
    name: "${friendly_name} Night Mode"
    entity_category: config
    restore_mode: RESTORE_DEFAULT_OFF
    lambda: |-
      return id(mini_night_mode_enabled);
    turn_on_action:
      - lambda: |-
          id(mini_night_mode_enabled) = true;
      - script.execute: mini_refresh_night_mode
    turn_off_action:
      - lambda: |-
          id(mini_night_mode_enabled) = false;
      - script.execute: mini_refresh_night_mode

select:
  - platform: template
    id: mini_night_mode_override_select
    name: "${friendly_name} Night Mode Override"
    entity_category: config
    optimistic: true
    restore_value: true
    initial_option: "Auto"
    options:
      - "Auto"
      - "Force Off"
      - "Force On"
    set_action:
      - lambda: |-
          int override = 0;
          if (x == "Force Off")      override = 1;
          else if (x == "Force On") override = 2;
          id(mini_night_mode_override) = override;
      - script.execute: mini_refresh_night_mode

interval:
  - interval: 1min
    then:
      - script.execute: mini_refresh_night_mode

# Call this from sensors on_value to ensure the strip follows the correct mode/effect.
script:
  - id: mini_apply_led_state
    mode: restart
    then:
      - lambda: |-
          const float night_brightness = ${night_brightness};
          if (id(mini_is_night_mode_now)) {
            if (night_brightness <= 0.0001f) {
              id(mini_led_strip).turn_off();
            } else {
              auto call = id(mini_led_strip).turn_on();
              call.set_transition_length(500);
              call.set_effect("None");
              call.set_brightness(night_brightness);
              call.set_rgb(1.0f, 1.0f, 1.0f);
              call.perform();
            }
          } else {
            auto call = id(mini_led_strip).turn_on();
            call.set_effect("AirIQ 4-LED Status");
            call.perform();
          }

  - id: mini_refresh_night_mode
    mode: restart
    then:
      - lambda: |-
          bool should_be_night = false;
          const int override = id(mini_night_mode_override);
          if (override == 2) {
            should_be_night = true;
          } else if (override == 1) {
            should_be_night = false;
          } else if (id(mini_night_mode_enabled)) {
            auto now = id(homeassistant_time).now();
            if (now.is_valid()) {
              const int start_minutes = ${night_mode_start_hour} * 60 + ${night_mode_start_minute};
              const int end_minutes   = ${night_mode_end_hour} * 60 + ${night_mode_end_minute};
              const int cur_minutes   = now.hour * 60 + now.minute;

              if (start_minutes <= end_minutes) {
                should_be_night = (cur_minutes >= start_minutes && cur_minutes < end_minutes);
              } else {
                should_be_night = (cur_minutes >= start_minutes || cur_minutes < end_minutes);
              }
            }
          }

          id(mini_is_night_mode_now) = should_be_night;
      - script.execute: mini_apply_led_state

  - id: mini_update_4leds
    mode: restart
    then:
      - script.execute: mini_refresh_night_mode

text_sensor:
  # Highest severity pollutant (mini MVP)
  - platform: template
    id: mini_mvp_pollutant
    name: "${friendly_name} MVP Pollutant"
    icon: mdi:alert-circle-outline
    update_interval: 10s
    lambda: |-
      auto severity_for = [](float value, float good, float moderate, float unhealthy) -> int {
        if (value < good)          return 0;
        else if (value < moderate) return 1;
        else if (value < unhealthy) return 2;
        else                        return 3;
      };

      int worst_level = -1;
      const char *worst_name = "Unknown";

      if (id(pm_2_5).has_state()) {
        const int lvl = severity_for(id(pm_2_5).state, id(g_pm25_good), id(g_pm25_moderate), id(g_pm25_unhealthy));
        if (lvl > worst_level) { worst_level = lvl; worst_name = "PM2.5"; }
      }

      if (id(voc_index).has_state()) {
        const int lvl = severity_for(id(voc_index).state, id(g_voc_good), id(g_voc_moderate), id(g_voc_unhealthy));
        if (lvl > worst_level) { worst_level = lvl; worst_name = "VOC"; }
      }

      if (id(nox_index).has_state()) {
        const int lvl = severity_for(id(nox_index).state, id(g_nox_good), id(g_nox_moderate), id(g_nox_unhealthy));
        if (lvl > worst_level) { worst_level = lvl; worst_name = "NOx"; }
      }

      if (id(co2_display).has_state()) {
        const int lvl = severity_for(id(co2_display).state, id(g_co2_good), id(g_co2_moderate), id(g_co2_unhealthy));
        if (lvl > worst_level) { worst_level = lvl; worst_name = "CO₂"; }
      }

      return std::string(worst_name);

  - platform: template
    id: mini_mvp_severity
    name: "${friendly_name} MVP Severity"
    icon: mdi:alpha-s-circle-outline
    update_interval: 10s
    lambda: |-
      auto severity_for = [](float value, float good, float moderate, float unhealthy) -> int {
        if (value < good)          return 0;
        else if (value < moderate) return 1;
        else if (value < unhealthy) return 2;
        else                        return 3;
      };

      int worst_level = -1;

      if (id(pm_2_5).has_state()) {
        worst_level = std::max(worst_level, severity_for(id(pm_2_5).state, id(g_pm25_good), id(g_pm25_moderate), id(g_pm25_unhealthy)));
      }
      if (id(voc_index).has_state()) {
        worst_level = std::max(worst_level, severity_for(id(voc_index).state, id(g_voc_good), id(g_voc_moderate), id(g_voc_unhealthy)));
      }
      if (id(nox_index).has_state()) {
        worst_level = std::max(worst_level, severity_for(id(nox_index).state, id(g_nox_good), id(g_nox_moderate), id(g_nox_unhealthy)));
      }
      if (id(co2_display).has_state()) {
        worst_level = std::max(worst_level, severity_for(id(co2_display).state, id(g_co2_good), id(g_co2_moderate), id(g_co2_unhealthy)));
      }

      switch (worst_level) {
        case 0: return std::string("Good");
        case 1: return std::string("Moderate");
        case 2: return std::string("Unhealthy");
        case 3: return std::string("Poor");
        default: return std::string("Unknown");
      }

# Optional: turn on the effect at boot so LEDs reflect status immediately.
# comment out if you don't want LEDs on by default.
esphome:
  on_boot:
    priority: -10
    then:
      - script.execute: mini_refresh_night_mode
