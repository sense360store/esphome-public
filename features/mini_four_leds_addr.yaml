# Mini: 4 addressable LEDs on one pin (WS2812/NeoPixel etc.)
# LED 0 = PM (SEN55 PM2.5), LED 1 = VOC (SEN55 VOC index),
# LED 2 = NOx (SEN55 NOx index), LED 3 = CO₂ (SCD4x via co2_display)
# Colors per sensor state:
#   Good = Green, Moderate = Orange, Unhealthy = Red, Poor = Purple

# Requires substitutions in your main YAML:
#   led_data_pin: <GPIO>
#   led_count: "4"
#   led_chipset: ws2812
#   led_rgb_order: GRB
#
# Requires the following IDs to exist (from airiq_mini_profile.yaml):
#   pm_2_5, voc_index, nox_index, co2_display
#   g_pm25_good/g_pm25_moderate/g_pm25_unhealthy
#   g_voc_good/g_voc_moderate/g_voc_unhealthy
#   g_nox_good/g_nox_moderate/g_nox_unhealthy
#   g_co2_good/g_co2_moderate/g_co2_unhealthy

light:
  - platform: esp32_rmt_led_strip
    id: mini_led_strip
    name: "${friendly_name} Mini LED Strip"
    pin: ${led_data_pin}
    num_leds: ${led_count}
    chipset: ${led_chipset}
    rgb_order: ${led_rgb_order}
    restore_mode: ALWAYS_OFF
    effects:
      - addressable_lambda:
          name: "AirIQ 4-LED Status"
          update_interval: 1s
          lambda: |-
            const int LEVEL_UNKNOWN = -1;

            // Map 0=Good, 1=Moderate, 2=Unhealthy, 3=Poor, -1=Unknown
            // Unknown -> dim blue/gray, Good -> Green, Moderate -> Orange,
            // Unhealthy -> Red, Poor -> Purple
            auto color_for = [&](int level) -> Color {
              switch (level) {
                case LEVEL_UNKNOWN: return Color(24, 32, 64);   // Unknown (off/gray/blue)
                case 0:              return Color(0, 255, 0);   // Green
                case 1:              return Color(255, 128, 0); // Orange
                case 2:              return Color(255, 0, 0);   // Red
                default:             return Color(128, 0, 255); // Purple
              }
            };

            auto scale_color = [&](Color c, float scale) -> Color {
              return Color(uint8_t(c.red * scale),
                           uint8_t(c.green * scale),
                           uint8_t(c.blue * scale));
            };

            // --- PM (use PM2.5)
            int lvl_pm = LEVEL_UNKNOWN;
            if (id(pm_2_5).has_state()) {
              const float v = id(pm_2_5).state;
              if (v < id(g_pm25_good))            lvl_pm = 0;
              else if (v < id(g_pm25_moderate))   lvl_pm = 1;
              else if (v < id(g_pm25_unhealthy))  lvl_pm = 2;
              else                                 lvl_pm = 3;
            }

            // --- VOC index
            int lvl_voc = LEVEL_UNKNOWN;
            if (id(voc_index).has_state()) {
              const float v = id(voc_index).state;
              if (v < id(g_voc_good))            lvl_voc = 0;
              else if (v < id(g_voc_moderate))   lvl_voc = 1;
              else if (v < id(g_voc_unhealthy))  lvl_voc = 2;
              else                                lvl_voc = 3;
            }

            // --- NOx index
            int lvl_nox = LEVEL_UNKNOWN;
            if (id(nox_index).has_state()) {
              const float v = id(nox_index).state;
              if (v < id(g_nox_good))            lvl_nox = 0;
              else if (v < id(g_nox_moderate))   lvl_nox = 1;
              else if (v < id(g_nox_unhealthy))  lvl_nox = 2;
              else                                lvl_nox = 3;
            }

            // --- CO2 (ppm) via co2_display (never "Unknown")
            int lvl_co2 = LEVEL_UNKNOWN;
            if (id(co2_display).has_state()) {
              const float v = id(co2_display).state;
              if (v < id(g_co2_good))            lvl_co2 = 0;
              else if (v < id(g_co2_moderate))   lvl_co2 = 1;
              else if (v < id(g_co2_unhealthy))  lvl_co2 = 2;
              else                                lvl_co2 = 3;
            }

            const int max_lvl = std::max(std::max(lvl_pm, lvl_voc), std::max(lvl_nox, lvl_co2));
            const float brightness_scale =
              (max_lvl == 0) ? 0.40f :
              (max_lvl == 1) ? 0.60f :
              (max_lvl == 2) ? 0.80f :
                                 1.00f;

            if (it.size() < 4) return;  // need 4 pixels
            it[0] = scale_color(color_for(lvl_pm), brightness_scale);   // PM
            it[1] = scale_color(color_for(lvl_voc), brightness_scale);  // VOC
            it[2] = scale_color(color_for(lvl_nox), brightness_scale);  // NOx
            it[3] = scale_color(color_for(lvl_co2), brightness_scale);  // CO₂

# Call this from sensors on_value to ensure the strip is on with the correct effect.
script:
  - id: mini_update_4leds
    mode: restart
    then:
      - light.turn_on:
          id: mini_led_strip
          effect: "AirIQ 4-LED Status"

text_sensor:
  # Highest severity pollutant (mini MVP)
  - platform: template
    id: mini_mvp_pollutant
    name: "${friendly_name} MVP Pollutant"
    icon: mdi:alert-circle-outline
    update_interval: 10s
    lambda: |-
      auto severity_for = [](float value, float good, float moderate, float unhealthy) -> int {
        if (value < good)          return 0;
        else if (value < moderate) return 1;
        else if (value < unhealthy) return 2;
        else                        return 3;
      };

      int worst_level = -1;
      const char *worst_name = "Unknown";

      if (id(pm_2_5).has_state()) {
        const int lvl = severity_for(id(pm_2_5).state, id(g_pm25_good), id(g_pm25_moderate), id(g_pm25_unhealthy));
        if (lvl > worst_level) { worst_level = lvl; worst_name = "PM2.5"; }
      }

      if (id(voc_index).has_state()) {
        const int lvl = severity_for(id(voc_index).state, id(g_voc_good), id(g_voc_moderate), id(g_voc_unhealthy));
        if (lvl > worst_level) { worst_level = lvl; worst_name = "VOC"; }
      }

      if (id(nox_index).has_state()) {
        const int lvl = severity_for(id(nox_index).state, id(g_nox_good), id(g_nox_moderate), id(g_nox_unhealthy));
        if (lvl > worst_level) { worst_level = lvl; worst_name = "NOx"; }
      }

      if (id(co2_display).has_state()) {
        const int lvl = severity_for(id(co2_display).state, id(g_co2_good), id(g_co2_moderate), id(g_co2_unhealthy));
        if (lvl > worst_level) { worst_level = lvl; worst_name = "CO₂"; }
      }

      return std::string(worst_name);

  - platform: template
    id: mini_mvp_severity
    name: "${friendly_name} MVP Severity"
    icon: mdi:alpha-s-circle-outline
    update_interval: 10s
    lambda: |-
      auto severity_for = [](float value, float good, float moderate, float unhealthy) -> int {
        if (value < good)          return 0;
        else if (value < moderate) return 1;
        else if (value < unhealthy) return 2;
        else                        return 3;
      };

      int worst_level = -1;

      if (id(pm_2_5).has_state()) {
        worst_level = std::max(worst_level, severity_for(id(pm_2_5).state, id(g_pm25_good), id(g_pm25_moderate), id(g_pm25_unhealthy)));
      }
      if (id(voc_index).has_state()) {
        worst_level = std::max(worst_level, severity_for(id(voc_index).state, id(g_voc_good), id(g_voc_moderate), id(g_voc_unhealthy)));
      }
      if (id(nox_index).has_state()) {
        worst_level = std::max(worst_level, severity_for(id(nox_index).state, id(g_nox_good), id(g_nox_moderate), id(g_nox_unhealthy)));
      }
      if (id(co2_display).has_state()) {
        worst_level = std::max(worst_level, severity_for(id(co2_display).state, id(g_co2_good), id(g_co2_moderate), id(g_co2_unhealthy)));
      }

      switch (worst_level) {
        case 0: return std::string("Good");
        case 1: return std::string("Moderate");
        case 2: return std::string("Unhealthy");
        case 3: return std::string("Poor");
        default: return std::string("Unknown");
      }

# Optional: turn on the effect at boot so LEDs reflect status immediately.
# comment out if you don't want LEDs on by default.
esphome:
  on_boot:
    priority: -10
    then:
      - light.turn_on:
          id: mini_led_strip
          effect: "AirIQ 4-LED Status"
          brightness: 50%
