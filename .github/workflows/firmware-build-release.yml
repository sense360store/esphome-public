---
# ============================================================================
# FIRMWARE BUILD & RELEASE WORKFLOW
# ============================================================================
# This workflow automates the build and release of ESPHome firmware binaries
# for all Sense360 products. It integrates with WebFlash for browser-based
# device flashing.
#
# Triggers:
#   - Release creation (published)
#   - Manual dispatch (for testing/preview releases)
#
# Process:
#   1. Generate build matrix from products directory
#   2. Build all product configurations using ESPHome
#   3. Rename binaries to WebFlash-compatible format
#   4. Attach binaries to GitHub release with checksums
#
# Output Format:
#   Sense360-[Product]-[Variant]-v[Version]-[Channel].bin
#
# ============================================================================

name: Build & Release Firmware

on:
  release:
    types: [published]

  workflow_dispatch:
    inputs:
      version:
        description: 'Version number (e.g., 3.0.0)'
        required: true
        default: '0.0.0-dev'
      channel:
        description: 'Release channel'
        required: true
        default: 'preview'
        type: choice
        options:
          - stable
          - preview
          - beta

# Ensure only one release workflow runs at a time
concurrency:
  group: firmware-release-${{ github.ref }}
  cancel-in-progress: false

env:
  ESPHOME_VERSION: "2025.3.0"

jobs:
  # ============================================================================
  # JOB 1: GENERATE BUILD MATRIX
  # ============================================================================
  # Scans the products directory and generates a build matrix for all
  # product configurations.
  # ============================================================================
  generate-matrix:
    name: Generate Build Matrix
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.generate.outputs.matrix }}
      product_count: ${{ steps.generate.outputs.product_count }}
      version: ${{ steps.version.outputs.version }}
      channel: ${{ steps.version.outputs.channel }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Determine version and channel
        id: version
        run: |
          if [ "${{ github.event_name }}" = "release" ]; then
            # Extract version from release tag (remove 'v' prefix if present)
            VERSION="${{ github.event.release.tag_name }}"
            VERSION="${VERSION#v}"

            # Determine channel from prerelease status
            if [ "${{ github.event.release.prerelease }}" = "true" ]; then
              CHANNEL="preview"
            else
              CHANNEL="stable"
            fi
          else
            # Manual dispatch
            VERSION="${{ github.event.inputs.version }}"
            CHANNEL="${{ github.event.inputs.channel }}"
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "channel=$CHANNEL" >> $GITHUB_OUTPUT
          echo "Building version: $VERSION (channel: $CHANNEL)"

      - name: Generate product build matrix
        id: generate
        run: |
          # Find all product YAML files
          PRODUCTS=$(find products/ -name "*.yaml" -type f | sort)

          # Build JSON matrix
          MATRIX='{"include":['
          FIRST=true
          COUNT=0

          for PRODUCT_FILE in $PRODUCTS; do
            # Extract product name (without path and extension)
            PRODUCT_NAME=$(basename "$PRODUCT_FILE" .yaml)

            # Skip secrets.yaml if it exists
            if [ "$PRODUCT_NAME" = "secrets" ]; then
              continue
            fi

            if [ "$FIRST" = true ]; then
              FIRST=false
            else
              MATRIX+=','
            fi

            MATRIX+="{\"product\":\"$PRODUCT_NAME\",\"file\":\"$PRODUCT_FILE\"}"
            COUNT=$((COUNT + 1))
          done

          MATRIX+=']}'

          echo "matrix=$MATRIX" >> $GITHUB_OUTPUT
          echo "product_count=$COUNT" >> $GITHUB_OUTPUT
          echo "Found $COUNT products to build"
          echo "Matrix: $MATRIX"

  # ============================================================================
  # JOB 2: BUILD FIRMWARE
  # ============================================================================
  # Compiles each product configuration and renames the output binary
  # to WebFlash-compatible format.
  # ============================================================================
  build:
    name: "Build: ${{ matrix.product }}"
    needs: generate-matrix
    runs-on: ubuntu-latest
    strategy:
      matrix: ${{ fromJson(needs.generate-matrix.outputs.matrix) }}
      fail-fast: false
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Cache PlatformIO
        uses: actions/cache@v4
        with:
          path: |
            ~/.platformio
            ~/.cache/pip
          key: ${{ runner.os }}-pio-${{ hashFiles('**/platformio.ini') }}-${{ matrix.product }}
          restore-keys: |
            ${{ runner.os }}-pio-${{ hashFiles('**/platformio.ini') }}-
            ${{ runner.os }}-pio-

      - name: Install ESPHome
        run: |
          pip install esphome==${{ env.ESPHOME_VERSION }}

      - name: Create secrets.yaml for build
        run: |
          cat > secrets.yaml << 'EOF'
          wifi_ssid: "Sense360_Setup"
          wifi_password: "sense360setup"
          api_encryption_key: "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa="
          ota_password: "sense360-ota-default"
          fallback_ap_password: "sense360fallback"
          web_username: "admin"
          web_password: "sense360admin"
          EOF
          # Copy secrets to all locations where configs might look for them
          cp secrets.yaml products/secrets.yaml
          mkdir -p tests/generated
          cp secrets.yaml tests/secrets.yaml
          cp secrets.yaml tests/generated/secrets.yaml

      - name: Compile firmware
        run: |
          echo "=============================================="
          echo "Compiling: ${{ matrix.file }}"
          echo "ESPHome version: ${{ env.ESPHOME_VERSION }}"
          echo "=============================================="
          # First validate config to catch errors early
          esphome config ${{ matrix.file }} > /dev/null
          echo "Config validation passed, starting compilation..."
          OUTPUT_DIR="firmware-output"
          OUTPUT_FILE="$OUTPUT_DIR/${{ matrix.product }}.bin"
          mkdir -p "$OUTPUT_DIR"
          echo "Requested output file: $OUTPUT_FILE"

          if esphome compile --help 2>&1 | grep -q -- '--output-file'; then
            echo "Using --output-file flag for deterministic binary path"
            COMPILE_CMD=(esphome compile "${{ matrix.file }}" --output-file "$OUTPUT_FILE")
          else
            echo "--output-file flag not available; compiling with default output location"
            COMPILE_CMD=(esphome compile "${{ matrix.file }}")
          fi

          # Compile with verbose output on failure
          if ! "${COMPILE_CMD[@]}"; then
            echo "=============================================="
            echo "COMPILATION FAILED"
            echo "=============================================="
            echo "Showing build directory contents:"
            find .esphome -type f -name "*.log" 2>/dev/null | head -5 | xargs cat 2>/dev/null || true
            exit 2
          fi

      - name: Find and rename firmware binary
        id: rename
        run: |
          echo "Searching for firmware binary..."

          # Prefer the explicitly requested output file from the compile step
          OUTPUT_FILE="firmware-output/${{ matrix.product }}.bin"
          FIRMWARE_PATH=""

          if [ -f "$OUTPUT_FILE" ]; then
            echo "Found firmware at explicit output path: $OUTPUT_FILE"
            FIRMWARE_PATH="$OUTPUT_FILE"
          else
            echo "Explicit output file not found. Falling back to search in .esphome and build directories..."

            # ESPHome with ESP-IDF outputs to various locations depending on version
            SEARCH_ROOTS=$(find . -type d -name ".esphome" -prune -print)
            if [ -d build ]; then
              SEARCH_ROOTS="$SEARCH_ROOTS build"
            fi

            for ROOT in $SEARCH_ROOTS; do
              BASE_DIR="$ROOT"
              [ -d "$ROOT/build" ] && BASE_DIR="$ROOT/build"

              # Pattern 1: Standard firmware.bin
              if [ -z "$FIRMWARE_PATH" ]; then
                FIRMWARE_PATH=$(find "$BASE_DIR" -name "firmware.bin" -type f 2>/dev/null | head -1)
              fi

              # Pattern 2: Factory bin (ESP-IDF merged binary for initial flash)
              if [ -z "$FIRMWARE_PATH" ]; then
                FIRMWARE_PATH=$(find "$BASE_DIR" -name "firmware-factory.bin" -type f 2>/dev/null | head -1)
              fi

              # Pattern 3: ESP-IDF style merged binary
              if [ -z "$FIRMWARE_PATH" ]; then
                FIRMWARE_PATH=$(find "$BASE_DIR" -path "*/.pioenvs/*/firmware*.bin" -type f 2>/dev/null | head -1)
              fi

              # Pattern 4: Any .bin file in idedata directory (ESP-IDF)
              if [ -z "$FIRMWARE_PATH" ]; then
                FIRMWARE_PATH=$(find "$BASE_DIR" -path "*/idedata/*" -name "*.bin" -type f 2>/dev/null | grep -v bootloader | head -1)
              fi

              # Pattern 5: Last resort - any firmware*.bin
              if [ -z "$FIRMWARE_PATH" ]; then
                FIRMWARE_PATH=$(find "$BASE_DIR" -name "firmware*.bin" -type f 2>/dev/null | head -1)
              fi
            done
          fi

          if [ -z "$FIRMWARE_PATH" ]; then
            echo "=============================================="
            echo "Error: Could not find compiled firmware binary"
            echo "=============================================="
            echo "Available .bin files:"
            find . -path "*/.esphome/build/*" -type f -name "*.bin" 2>/dev/null || echo "No .bin files found"
            echo ""
            echo "Build directory structure:"
            find . -path "*/.esphome/build" -type d 2>/dev/null || echo "No build directory"
            exit 1
          fi

          echo "Found firmware at: $FIRMWARE_PATH"
          echo "File size: $(stat -c%s "$FIRMWARE_PATH") bytes"

          # Generate WebFlash-compatible filename
          VERSION="${{ needs.generate-matrix.outputs.version }}"
          CHANNEL="${{ needs.generate-matrix.outputs.channel }}"
          WEBFLASH_NAME=$(python3 scripts/product_name_mapper.py "${{ matrix.product }}" "$VERSION" "$CHANNEL")

          echo "Renaming to: $WEBFLASH_NAME"

          # Create output directory and copy with new name
          mkdir -p firmware-output
          cp "$FIRMWARE_PATH" "firmware-output/$WEBFLASH_NAME"

          echo "webflash_name=$WEBFLASH_NAME" >> $GITHUB_OUTPUT
          echo "firmware_path=firmware-output/$WEBFLASH_NAME" >> $GITHUB_OUTPUT

      - name: Upload firmware artifact
        uses: actions/upload-artifact@v4
        with:
          name: firmware-${{ matrix.product }}
          path: ${{ steps.rename.outputs.firmware_path }}
          retention-days: 7
          if-no-files-found: error

  # ============================================================================
  # JOB 3: RELEASE ATTACHMENT
  # ============================================================================
  # Downloads all compiled binaries, generates checksums, and attaches
  # them to the GitHub release.
  # ============================================================================
  release:
    name: Attach to Release
    needs: [generate-matrix, build]
    runs-on: ubuntu-latest
    if: github.event_name == 'release'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download all firmware artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: firmware-*
          path: all-firmware
          merge-multiple: true

      - name: List downloaded firmware
        run: |
          echo "Downloaded firmware files:"
          ls -la all-firmware/
          echo ""
          echo "Total files: $(ls -1 all-firmware/*.bin 2>/dev/null | wc -l)"

      - name: Generate checksums
        run: |
          cd all-firmware

          # Generate SHA256 checksums
          echo "# SHA256 Checksums" > checksums-sha256.txt
          echo "# Generated: $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> checksums-sha256.txt
          echo "# Version: ${{ needs.generate-matrix.outputs.version }}" >> checksums-sha256.txt
          echo "# Channel: ${{ needs.generate-matrix.outputs.channel }}" >> checksums-sha256.txt
          echo "" >> checksums-sha256.txt
          sha256sum *.bin >> checksums-sha256.txt

          # Generate MD5 checksums (for compatibility)
          echo "# MD5 Checksums" > checksums-md5.txt
          echo "# Generated: $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> checksums-md5.txt
          echo "" >> checksums-md5.txt
          md5sum *.bin >> checksums-md5.txt

          echo "Checksums generated:"
          cat checksums-sha256.txt

      - name: Create firmware manifest
        run: |
          VERSION="${{ needs.generate-matrix.outputs.version }}"
          CHANNEL="${{ needs.generate-matrix.outputs.channel }}"

          cat > all-firmware/manifest.json << EOF
          {
            "version": "$VERSION",
            "channel": "$CHANNEL",
            "build_date": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "git_sha": "${{ github.sha }}",
            "esphome_version": "${{ env.ESPHOME_VERSION }}",
            "product_count": ${{ needs.generate-matrix.outputs.product_count }},
            "files": [
          $(ls -1 all-firmware/*.bin 2>/dev/null | while read f; do
            BASENAME=$(basename "$f")
            SHA256=$(sha256sum "$f" | cut -d' ' -f1)
            SIZE=$(stat -c%s "$f")
            echo "    {\"name\": \"$BASENAME\", \"sha256\": \"$SHA256\", \"size\": $SIZE},"
          done | sed '$ s/,$//')
            ]
          }
          EOF

          echo "Manifest created:"
          cat all-firmware/manifest.json

      - name: Upload release assets
        uses: softprops/action-gh-release@v2
        with:
          files: |
            all-firmware/*.bin
            all-firmware/checksums-sha256.txt
            all-firmware/checksums-md5.txt
            all-firmware/manifest.json
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Release summary
        run: |
          echo "=============================================="
          echo "FIRMWARE RELEASE COMPLETE"
          echo "=============================================="
          echo ""
          echo "Version: ${{ needs.generate-matrix.outputs.version }}"
          echo "Channel: ${{ needs.generate-matrix.outputs.channel }}"
          echo "Products built: ${{ needs.generate-matrix.outputs.product_count }}"
          echo "Git SHA: ${{ github.sha }}"
          echo ""
          echo "Firmware files attached to release:"
          ls -1 all-firmware/*.bin
          echo ""
          echo "WebFlash can now sync these binaries via the"
          echo "sync-from-releases.py script."

  # ============================================================================
  # JOB 4: BUILD SUMMARY (for manual dispatch)
  # ============================================================================
  # Provides a summary when manually triggered (no release attachment)
  # ============================================================================
  summary:
    name: Build Summary
    needs: [generate-matrix, build]
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'
    steps:
      - name: Download all firmware artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: firmware-*
          path: all-firmware
          merge-multiple: true

      - name: Build summary
        run: |
          echo "=============================================="
          echo "FIRMWARE BUILD COMPLETE (Preview)"
          echo "=============================================="
          echo ""
          echo "Version: ${{ needs.generate-matrix.outputs.version }}"
          echo "Channel: ${{ needs.generate-matrix.outputs.channel }}"
          echo "Products built: ${{ needs.generate-matrix.outputs.product_count }}"
          echo ""
          echo "Built firmware files:"
          ls -la all-firmware/
          echo ""
          echo "Note: This was a manual dispatch. To attach firmware"
          echo "to a release, create a GitHub release instead."
